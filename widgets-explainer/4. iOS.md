```swift
import WidgetKit
import SwiftUI
import ExpoModulesCore

struct UKBreakdownEntry: TimelineEntry {
  // always has a date as needs to know when to update
  let date: Date
  var totalPct: Int
  var fossilPct: Int
  var gasPct: Int
  var coalPct: Int
  var biomassPct: Int
  var nuclearPct: Int
  var hydroPct: Int
  var importsPct: Int
  var otherPct: Int
  var windPct: Int
  var solarPct: Int
  var yesterdayAvg: Int
  var yesterdayDir: String
  var day: Int
  var monthAvg: Int
  var yearAvg: Int
  var monthStr: String
  var month: Int
  var year: Int
  var fromISO: String
  var toISO: String
}

func parseISODate(isoString: String) -> (year: Int, month: Int, date: Int, monthStr: String, hour: Int, minute: Int)? {
  let dateFormatter = DateFormatter()
  dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm'Z'"
  dateFormatter.timeZone = TimeZone(identifier: "UTC")
 
  // let logger = Logger()
  // logger.info("Attempting to parse \(isoString)")
  
  var parsed = dateFormatter.date(from: isoString)
  
  if let _ = parsed {} else {
    dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss'Z'"
    parsed = dateFormatter.date(from: isoString)
  }
  
  if let date = parsed {
    let localDate = date.toLocalTime()
    let calendar = Calendar.current
    let components = calendar.dateComponents([
      .year,
      .month,
      .day,
      .hour,
      .minute
    ], from: localDate)
    
    let monthStr = calendar.monthSymbols[components.month! - 1]
    
    return (
      year: components.year!,
      month: components.month!,
      date: components.day!,
      monthStr: monthStr,
      hour: components.hour!,
      minute: components.minute!
    )
  }
  else {
    // logger.info("Cant parse iso date \(isoString)!")
    return nil
  }
}

func shouldUpdate(dateStr: String) -> Bool {
  // let logger = Logger()
  
  if (dateStr == "") {
    // logger.info("No date string; must update.")
    return true
  }
  
  guard let parsedDate = parseISODate(isoString: dateStr) else {
    // logger.warn("Unable to parse ISO Date string in shouldUpdate!")
    return true
  }
  
  let currentDate = Date()
  let currentComponents = Calendar.current.dateComponents([
    .year, .month, .day, .hour, .minute], from: currentDate)
  
  guard let parsedDateAsDate = Calendar.current.date(from: DateComponents(
    year: parsedDate.year,
    month: parsedDate.month,
    day: parsedDate.date,
    hour: parsedDate.hour,
    minute: parsedDate.minute
  )) else {
    // logger.warn("Unable to parse iso date to date in shouldUpdate()!")
    return true
  }
  
  let timeDifference = currentDate.timeIntervalSince(parsedDateAsDate)
  
  // if the time difference is +30 minutes need an update
  if (timeDifference >= 1800) {
    // logger.info("Should update based on minutes now time difference")
    return true
  }
  // get the time at either on the hour or half hour
  // so first check if the last data date (parsedDate) is on the hour (or close) and the last cached
  // timestamp was over 30
  else if (parsedDate.minute < 30 && currentComponents.minute! >= 30) {
    // logger.info("Should update based on minutes now over 30")
    return true
  }
  // else if its the other way around
  else if (parsedDate.minute >= 30 && currentComponents.minute! < 30) {
    // logger.info("Should update based on minutes now under 30")
    return true
  }
    
  // logger.info("Should not send update request")
  return false
}

func getBlankEntry() -> UKBreakdownEntry {
  return UKBreakdownEntry(
    date: getNextUpdateDate(),
    totalPct: 0,
    fossilPct: 0,
    gasPct: 0,
    coalPct: 0,
    biomassPct: 0,
    nuclearPct: 0,
    hydroPct: 0,
    importsPct: 0,
    otherPct: 0,
    windPct: 0,
    solarPct: 0,
    yesterdayAvg: 0,
    yesterdayDir: "UP",
    day: 1,
    monthAvg: 0,
    yearAvg: 0,
    monthStr: "June",
    month: 1,
    year: 2024,
    fromISO: "",
    toISO: ""
  )
}

func getISODate(date: Date) -> String {
  return ISO8601DateFormatter().string(from: date)
}

func getNextUpdateDate() -> Date {
  // let logger = Logger()
  // logger.warn("getNextUpdateDate()")
  let calendar = Calendar.current
  let currentDate = Date()
  // logger.warn("Current Date: \(currentDate)")
  let currentMinute = calendar.component(.minute, from: currentDate)
  var nextUpdateDate: Date
  
  if currentMinute < 31 {
    nextUpdateDate = calendar.date(bySetting: .minute, value: 31, of: currentDate)!
    // logger.warn("Set next update date to 31 minutes past")
  } else {
    let currentComponents = calendar.dateComponents(
      [.year,.month,.day,.hour],
      from: currentDate
    )
    var nextUpdateComponents = DateComponents()
    nextUpdateComponents.year = currentComponents.year
    nextUpdateComponents.month = currentComponents.month
    nextUpdateComponents.day = currentComponents.day
    nextUpdateComponents.hour = (currentComponents.hour ?? 0) + 1
    nextUpdateComponents.minute = 1
    nextUpdateDate = calendar.date(from: nextUpdateComponents)!
    // logger.warn("Set next update date to 1 minute past")
  }

  // logger.warn("Next update at \(nextUpdateDate).")
  return nextUpdateDate
}

func parseBreakdownToEntry(breakdown: UKBreakdown) -> UKBreakdownEntry? {
  // let logger = Logger()
  // round to the next 31 minutes past or 1 minute past
  let nextUpdateDate = getNextUpdateDate()
  
  guard let fromParsed = parseISODate(isoString: breakdown.fromISO) else {
    // logger.info("Unable to parse ISO Date \(breakdown.fromISO)")
    return nil
  }
  
  var averages = getCachedAverages()
  var yesterdayAvg = Int(averages?.yd.rounded() ?? 0)
  var monthAvg = Int(averages?.mo.rounded() ?? 0)
  var yearAvg = Int(averages?.yr.rounded() ?? 0)
  
  var entry = UKBreakdownEntry(
      date: nextUpdateDate,
      totalPct: breakdown.totalPct,
      fossilPct: breakdown.fossilPct,
      gasPct: breakdown.gasPct,
      coalPct: breakdown.coalPct,
      biomassPct: breakdown.biomassPct,
      nuclearPct: breakdown.nuclearPct,
      hydroPct: breakdown.hydroPct,
      importsPct: breakdown.importsPct,
      otherPct: breakdown.otherPct,
      windPct: breakdown.windPct,
      solarPct: breakdown.solarPct,
      yesterdayAvg: yesterdayAvg,
      yesterdayDir: yesterdayAvg < breakdown.totalPct ? "UP" : "DOWN",
      day: fromParsed.date,
      monthAvg: monthAvg,
      yearAvg: yearAvg,
      monthStr: fromParsed.monthStr,
      month: fromParsed.month,
      year: fromParsed.year,
      fromISO: breakdown.fromISO,
      toISO: breakdown.toISO
  )
  
  return entry
}

private func cacheAverages(averages: AveragesAPIResponse) {
  // let logger = Logger()

  do {
    let sharedContainer = UserDefaults(suiteName: "group.com.worldnetzero.ios.expowidgets")!
    let encoder = JSONEncoder()
    let json = try encoder.encode(averages)

    if let utf8json = String(data: json, encoding: .utf8) {
      sharedContainer.set(utf8json, forKey: "UKBDAverages")
      // logger.info("UKBreakdown averages cached!")
      // logger.info(utf8json)
    } else {
      // logger.warn("Unable to encode breakdown to UTF8!")
    }
  } catch {
    // logger.error("An error occured decoding UK breakdown: \(error.localizedDescription)")
  }
}

private func getCachedAverages() -> AveragesAPIResponse? {
  // let logger = Logger()
  let suiteKey = "group.com.worldnetzero.ios.expowidgets"
  let sharedContainer = UserDefaults(suiteName: suiteKey)!

  if let data = sharedContainer.string(forKey: "UKBDAverages") {
      do {
          // logger.info("averages found in shared container!")
          // logger.info("\(data)")
          let decoder = JSONDecoder()

          guard let unwrappedData = data.data(using: .utf8) else {
            // logger.warn("Unwrapping averages to utf8 failed!")
            return nil
          }

          let avgs = try decoder.decode(
            AveragesAPIResponse.self,
            from: unwrappedData
          )
        
          // logger.info("averages decoded!")
          // logger.info(avgs)
          return avgs
      } catch {
        // logger.error("An error occured decoding averages: \(error.localizedDescription)")
      }
  }
  else {
    //  logger.warn("No entry found for UserDefaults[UKBDAverages]")
  }

  return nil
}

private func cacheBreakdown(breakdown: UKBreakdown) {
  // let logger = Logger()

  do {
    let sharedContainer = UserDefaults(suiteName: "group.com.worldnetzero.ios.expowidgets")!
    let encoder = JSONEncoder()
    let json = try encoder.encode(breakdown)

    if let utf8json = String(data: json, encoding: .utf8) {
      sharedContainer.set(utf8json, forKey: "UKBreakdown")
      // logger.info("UKBreakdown cached!")
      // logger.info(utf8json)
    } else {
      // logger.warn("Unable to encode breakdown to UTF8!")
    }
  } catch {
    // logger.error("An error occured decoding UK breakdown: \(error.localizedDescription)")
  }
}

func getCachedBreakdown() -> UKBreakdown? {
  // let logger = Logger()
  let suiteKey = "group.com.worldnetzero.ios.expowidgets"
  let sharedContainer = UserDefaults(suiteName: suiteKey)!
  let fallbackEntry = getBlankEntry()

  if let data = sharedContainer.string(forKey: "UKBreakdown") {
      do {
          // logger.info("data found in shared container!")
          // logger.info("\(data)")
          let decoder = JSONDecoder()

          guard let unwrappedData = data.data(using: .utf8) else {
            return nil
          }

          let breakdown = try decoder.decode(
            UKBreakdown.self,
            from: unwrappedData
          )

          return breakdown
      } catch {
        // logger.error("An error occured decoding UK breakdown: \(error.localizedDescription)")
      }
  }
  else {
    //  logger.warn("No entry found for UserDefaults[UKBreakdown]")
  }

  return nil
}

func getCachedEntry() -> UKBreakdownEntry {
    // let logger = Logger()
    let suiteKey = "group.com.worldnetzero.ios.expowidgets"
    let sharedContainer = UserDefaults(suiteName: suiteKey)!
    let fallbackEntry = getBlankEntry()

    if let data = sharedContainer.string(forKey: "UKBreakdown") {
        do {
            // logger.info("data found in shared container!")
            // logger.info("\(data)")
            let decoder = JSONDecoder()
  
            guard let unwrappedData = data.data(using: .utf8) else {
              return fallbackEntry
            }

            let breakdown = try decoder.decode(
              UKBreakdown.self,
              from: unwrappedData
            )

            guard let entry = parseBreakdownToEntry(breakdown: breakdown) else {
              return fallbackEntry
            }
            // logger.info("Entry decoded")
            // logger.info(entry)
            return entry
        } catch {
          // logger.error("An error occured decoding UK breakdown: \(error.localizedDescription)")
        }
    }
    else {
      //  logger.warn("No entry found for UserDefaults[UKBreakdown]")
    }

  return fallbackEntry
}

func getUpdatedEntry(completion: @escaping (UKBreakdownEntry) -> Void) {
  // let logger = Logger()
  var cachedBreakdown = getCachedBreakdown()
  let entry: UKBreakdownEntry
  
  if let cachedBreakdown = cachedBreakdown {
    let parsed = parseBreakdownToEntry(breakdown: cachedBreakdown)

    if let unwrapped = parsed {
      // logger.warn("Entry decoded")
      // logger.warn(unwrapped)
    }
    entry = parsed ?? getBlankEntry()
  } else {
    // logger.warn("Cached entry nil, using blank entry")
    entry = getBlankEntry()
  }
  
  var requiresUpdate = shouldUpdate(dateStr: entry.toISO)
  
  if (!requiresUpdate) {
    // logger.warn("Update not required")
    return completion(entry)
  }
  
  // logger.warn("Update required!")
  return fetchData(cachedBreakdown: cachedBreakdown, completion: { breakdown in
    // logger.warn("Parsing breakdown to entry!")
    guard var newEntry = parseBreakdownToEntry(breakdown: breakdown!) else {
      // logger.warn("Parsing failed!")
      return completion(entry)
    }
    // logger.warn("Parsing worked!")
    // logger.warn(newEntry)
    completion(newEntry)
  })
}

struct AveragesAPIResponse: Codable {
  let ts: String
  let yd: Double
  let mo: Double
  let yr: Double
}

func shouldRequestAverages() -> Bool {
  // let logger = Logger()
  
  if let avgs = getCachedAverages() {
    // logger.info("Checking averages time stamp")
    var currentDate = Date()
    let currentComponents = Calendar.current.dateComponents([
      .year, .month, .day, .hour, .minute
    ], from: currentDate)
    
    guard let timeStamp = parseISODate(isoString: avgs.ts) else {
      // logger.warn("Unable to parse ISO Date \(avgs.ts) from avgs timestamp")
      return true
    }
    
    // logger.info("avgs timestamp date: \(timeStamp.date)")
    if let day = currentComponents.day {
      // logger.info("current date: \(day)")
    }
    let shouldReq = timeStamp.date != currentComponents.day
    // logger.info("Should request: \(shouldReq)")
    return shouldReq
  }
  
  // logger.info("Cached breakdown nil, must request averages")
  return true
}

internal func fetchData(cachedBreakdown: UKBreakdown?, completion: @escaping (UKBreakdown?) -> Void) {
  // let logger = Logger()
  guard let url = URL(string: "https://serverurl.com/api/getdata") else { return }
  
  // logger.info("Fetching data from NG and GC")

  let group = DispatchGroup()
  
  var breakdown: UKBreakdown?
  var response1: ResponseData?
  var response2: AveragesAPIResponse?
  
  let sendAvgsRequest = shouldRequestAverages()
  
  group.enter()
  URLSession.shared.dataTask(with: url) { data, response, error in
    defer { group.leave() }
    
    guard let data = data else { return }
    
    if let httpResponse = response as? HTTPURLResponse {
      if httpResponse.statusCode == 200 {
        do {
            let result = try JSONDecoder().decode(ResponseData.self, from: data)
            response1 = result
            breakdown = calculateBreakdown(from: result)
          
          if sendAvgsRequest {
            guard let avgsUrl = URL(string: "https://serverurl.com/api/getdata") else { return }
            
            group.enter()
            URLSession.shared.dataTask(with: avgsUrl) { data, response, error in
              defer {group.leave() }
              
              guard let data = data else { return }
              
              if let httpResponse = response as? HTTPURLResponse {
                if httpResponse.statusCode == 200 {
                  do {
                    let secondResult = try JSONDecoder().decode(AveragesAPIResponse.self, from: data)
                    response2 = secondResult
                  } catch {
                    // logger.error("An error occured decoding averages: \(error.localizedDescription)")
                  }
                }
                else {
                  // logger.warn("Status code \(httpResponse.statusCode) received from google cloud.")
                }
              }
              else {
                // logger.warn("Unparseable response received from google cloud.")
              }
            }.resume()
          }
        } catch {
          // logger.error("An error occured calculating breakdown: \(error.localizedDescription)")
        }
      }
      else {
        // logger.warn("Status code \(httpResponse.statusCode) received from national grid.")
      }
        
    } else {
      // logger.warn("Unparseable response received from national grid.")
    }
  }.resume()
  
  
  group.notify(queue: .main) {
    if var breakdown = breakdown, let _ = response1, let response2 = response2 {
      // logger.info("Caching data")
      // logger.info(breakdown)
      cacheBreakdown(breakdown: breakdown)
      // logger.info("Caching new averages")
      cacheAverages(averages: response2)
      // logger.info("Data cached")
      completion(breakdown)
    }
    else if var breakdown = breakdown, let _ = response1 {
      // logger.info("Caching data")
      // logger.info(breakdown)
      cacheBreakdown(breakdown: breakdown)
      // logger.info("Data cached")
      completion(breakdown)
    }
    else {
      completion(nil)
    }
  }
}

struct ResponseData: Codable {
  let data: GenerationData
}

struct GenerationData: Codable {
  let generationmix: [GenerationMix]
  let from: String
  let to: String
}

struct GenerationMix: Codable {
  let fuel: String
  let perc: Double
}

private func calculateBreakdown(from data: ResponseData) -> UKBreakdown {
    // Calculate total percentage and percentage for each fuel type
    let totalPct = data.data.generationmix.reduce(0) { result, mix in
        if ["biomass", "nuclear", "hydro", "wind", "solar"].contains(mix.fuel) {
            return result + mix.perc
        }
        return result
    }
    let fossilPct = data.data.generationmix.reduce(0) { result, mix in
        if ["coal", "gas", "imports", "other"].contains(mix.fuel) {
            return result + mix.perc
        }
        return result
    }
    let gasPct = data.data.generationmix.first { $0.fuel == "gas" }?.perc ?? 0
    let coalPct = data.data.generationmix.first { $0.fuel == "coal" }?.perc ?? 0
    let biomassPct = data.data.generationmix.first { $0.fuel == "biomass" }?.perc ?? 0
    let nuclearPct = data.data.generationmix.first { $0.fuel == "nuclear" }?.perc ?? 0
    let hydroPct = data.data.generationmix.first { $0.fuel == "hydro" }?.perc ?? 0
    let importsPct = data.data.generationmix.first { $0.fuel == "imports" }?.perc ?? 0
    let otherPct = data.data.generationmix.first { $0.fuel == "other" }?.perc ?? 0
    let windPct = data.data.generationmix.first { $0.fuel == "wind" }?.perc ?? 0
    let solarPct = data.data.generationmix.first { $0.fuel == "solar" }?.perc ?? 0
    
    // Calculate monthStr
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "MMM"
    let monthStr = dateFormatter.string(from: Date())
    
    // Create UKBreakdown entry
    let breakdown = UKBreakdown(
        version: "1.2",
        totalPct: Int(totalPct.rounded()),
        fossilPct: Int(fossilPct.rounded()),
        gasPct: Int(gasPct.rounded()),
        coalPct: Int(coalPct.rounded()),
        biomassPct: Int(biomassPct.rounded()),
        nuclearPct: Int(nuclearPct.rounded()),
        hydroPct: Int(hydroPct.rounded()),
        importsPct: Int(importsPct.rounded()),
        otherPct: Int(otherPct.rounded()),
        windPct: Int(windPct.rounded()),
        solarPct: Int(solarPct.rounded()),
        fromISO: String(data.data.from),
        toISO: String(data.data.to)
    )
    return breakdown
}

// this controls when to update the display
struct UKBreakdownProvider: TimelineProvider {
    typealias Entry = UKBreakdownEntry

    func placeholder(in context: Context) -> UKBreakdownEntry {
      getCachedEntry()
    }

    func getSnapshot( in context: Context, completion: @escaping (UKBreakdownEntry) -> ()) {
      getUpdatedEntry { entry in
        completion(entry)
      }
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {
      // let logger = Logger()
      // logger.warn("Getting timeline...")
      
      getUpdatedEntry { entry in
        let timeline = Timeline(entries: [ entry ], policy: .atEnd)
        // logger.warn("Timeline obtained")
        // logger.warn("Next Update Date: \(entry.date)")
        // logger.warn("\(entry)")
        completion(timeline)
      }
    }
}
```