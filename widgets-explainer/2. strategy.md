
# Data Transfer Between App And Widgets

This is an overview. Code samples are in "4. iOS" and "3. Android" files. I recommend you start with Android for designing widgets - with Android Studio it's really easy to move stuff around and there are less steps than to build iOS widgets.

# Data Restrictions & Pass Back

Both iOS and Android have restrictions on when widgets can request data. However, there are no restrictions on sending data from app to widget when the app is open. If the app isn't open, then the widget can't talk to it reliably. So, to get around that, you can either:

1. Use deep linking if your data is simple. This is pretty quick and reliable.
2. Use a cache (UserDefaults iOS, Preferences android) and add a strategy in-app to request the data within the cache when opened/focused.

# Sending data to the widget

If you need to send data TO the widget, then you can use the following within your app:

```javascript
function sendWidgetData() {
    const androidPackage = Constants.expoConfig?.android?.package;

    if (Platform.OS === 'ios') {
      const json = JSON.stringify({ message: 'Hello from app!' });
      ExpoWidgetsModule.setWidgetData(json);
    } else if (androidPackage) {
      const json = JSON.stringify({ message: 'Hello from app!' });
      ExpoWidgetsModule.setWidgetData(json, androidPackage);
    }
  }
  ```
NB: Adding a type property to the object  ( like `{ payload: 'Some data', type: 'MY_TYPE' }` ) will allow you to easily filter the received data in swift + kotlin.

# Updating widget data

If your widget needs to keep up-to-date with data, then you should use the platforms prefered widget update strategy. For iOS, that's using a timeline provider and for android it's using a provider and setting android:updatePeriodMillis within the widget xml.

```xml
  <appwidget-provider
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:updatePeriodMillis="1800000"  <!-- 30 minutes -->
    android:minWidth="200dp"
    android:minHeight="200dp"
    android:initialLayout="@layout/widget_layout" />
```

Then, request data directly from your server API's. For UK Zero, I wrote a specific endpoint per widget with just the data required to reduce request load. This made sense for that app simple because data is only updated every 30 minutes or so by third parties. If you have more complex requirements then you'll need to implement a strategy for how often to update your widgets.

In iOS you can see the fetchData function (line 450) in ios.md for a clear picture on how to send a HTTP request. For android, see the getFreshData function (line 477). Note that there were two endpoints requested in android BECAUSE I WAS LAZY and short on time, so it's actually requesting multiple widgets data. It's ideal to have a widget provider per widget.

# Android Updates

To create a provider, add a file "{YourWidgetName}Provider.kt" in /widgetfolder/android/src/main/java/package_name.

Then, add a "{widgetname}_widget_info.xml" file in /widgetfolder/android/src/res/xml" that contains the widget layout and the initial data. Here's an example:

```xml
<receiver android:name=".WidgetOneProvider">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/widget_one_info" />
</receiver>

<receiver android:name=".WidgetTwoProvider">
    <intent-filter>
        <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data
        android:name="android.appwidget.provider"
        android:resource="@xml/widget_two_info" />
</receiver>
```

For iOS, just create a "{YourWidgetName}Provider.swift" in /widgetfolder/ios. Here add a timeline provider, like:

```swift
struct MyWidget1Provider: TimelineProvider {
    typealias Entry = MyDataModel

    func placeholder(in context: Context) -> MyDataModel {
      getCachedEntry()
    }

    func getSnapshot( in context: Context, completion: @escaping (MyDataModel) -> ()) {
      getUpdatedEntry { entry in
        completion(entry)
      }
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {      
      getUpdatedEntry { entry in
        let timeline = Timeline(entries: [ entry ], policy: .atEnd)
        completion(timeline)
      }
    }
}
```

You then pass this timeline provider to your widget configuration. Here's the UK Zero one:

```swift
var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: UKBreakdownProvider()) { entry in
            UKBreakdownEntryView(entry: entry)
              .background(.white)
        }
        .configurationDisplayName("UK Breakdown")
        .description("The UK renewable energy breakdown.")
        .supportedFamilies([
          .systemMedium,
        ])
        .contentMarginsDisabledIfAvailable()
    }
```

The getTimeline function in the provider controls how often to get new data. In the example, there's an entry which gets set on beginning. The entry has a date field, and THAT is what controls when the next policy update will be (as long as it is within the iOS requirements aka in 10 seconds might not trigger).


I'm using .atEnd which means the widget will not automatically refresh until it reaches the end of the policy (a policy can have multiple entries). Once it reaches that point, the system may request a new timeline entry based on its own scheduling. 

Here's another example from GPT which shows a super simple provider:

```swift
import WidgetKit
import SwiftUI
import Combine

struct SimpleEntry: TimelineEntry {
    let date: Date
    let data: String // Change this to your desired data type
}

struct SimpleTimelineProvider: TimelineProvider {
    typealias Entry = SimpleEntry

    func placeholder(in context: Context) -> SimpleEntry {
        SimpleEntry(date: Date(), data: "Loading...")
    }

    func getSnapshot(in context: Context, completion: @escaping (SimpleEntry) -> ()) {
        let entry = SimpleEntry(date: Date(), data: "Snapshot data")
        completion(entry)
    }

    func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {
        fetchData { data in
            let currentDate = Date()
            let nextUpdate = Calendar.current.date(byAdding: .minute, value: 15, to: currentDate) ?? currentDate
            
            let entry = SimpleEntry(date: currentDate, data: data)
            let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
            completion(timeline)
        }
    }

    private func fetchData(completion: @escaping (String) -> ()) {
        // Replace with your API URL
        let url = URL(string: "https://api.example.com/data")!

        URLSession.shared.dataTask(with: url) { data, response, error in
            var resultData: String = "Error fetching data"
            if let data = data, let fetchedData = String(data: data, encoding: .utf8) {
                resultData = fetchedData // Process the response data as needed
            }
            completion(resultData)
        }.resume()
    }
}

// The SwiftUI view to display the widget
struct SimpleWidgetEntryView: View {
    var entry: SimpleEntry

    var body: some View {
        Text(entry.data)
            .padding()
    }
}

// The widget configuration
@main
struct SimpleWidget: Widget {
    let kind: String = "SimpleWidget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: SimpleTimelineProvider()) { entry in
            SimpleWidgetEntryView(entry: entry)
        }
        .configurationDisplayName("Simple Widget")
        .description("This is a simple widget that fetches data every 15 minutes.")
        .supportedFamilies([.systemSmall])
    }
}
```

```swift
func getTimeline(in context: Context, completion: @escaping (Timeline<Entry>) -> ()) {
    getUpdatedEntry { entry in
        let currentDate = Date()
        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 20, to: currentDate) ?? currentDate
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
        completion(timeline)
    }
}
```

# Update Limitations

Android has a lower limit of 30 minutes for updatePeriodMillis. iOS timeline providers have a 5 min minimum, but also a cap of 70 updates a day. When designing widgets you should bare this in mind. Both platforms do not guarentee widget updates, and offer a "best attempt" strategy. If the phone is busy, or for other magical reasons, the update may not happen. Both platforms advise widgets only show data that's ok to be a little stale. This excludes fancy things like live update widgets (e.g. the bar you get when ordering an uber that updates in real time). 

