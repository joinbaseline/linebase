
# Presetup

Run 
```
npx expo install @bittingz/expo-widgets
```

Create a widget folder in your project e.g. /widgets. 
Create two sub-folders: widgets/ios and widgets/android. This is where all native widget code should belong.
Update your app.config.(js/ts) with the following (or the ts equivalent):

```typescript
"plugins": [
    [
        "../app.plugin.js",
        {
            "ios": {
            "src": "./widgets/ios",
            "mode": "development",
            "moduleDependencies": [
                "MyData.swift",
                "LogHandler.swift"
            ]
            },
            "android": {
            "src": "./widgets/android",
            "widgets": [
                {
                "name": "SampleWidget",
                "resourceName": "@xml/sample_widget_info"
                }
            ]
            }
        }
    ]
],
```

Copy over the example projects android and ios folders (https://github.com/gitn00b1337/expo-widgets/tree/main/example/widgets).
Run the following command to build the project:
```
npx expo run:android
npx expo run:ios
```

NB: Whenever you make changes, make sure to clear the caches or run the following prebuild commands:
EXPO_NO_CACHE=true EXPO_NO_GIT_STATUS=true expo prebuild -p ios --clean
EXPO_NO_CACHE=true EXPO_NO_GIT_STATUS=true expo prebuild -p android --clean

If there are any issues getting to this point let me know!

# iOS Guide
1. The "entry point" for widgets is the WidgetBundle file. This shows which widgets are available from the app. If you add widget files (discussed in a sec) but don't add them here, they won't be available.
2. The example has one widget, shown in MyWidget.swift.
3. The following defines a widget config:
```
struct MyWidget: Widget
```
4. Each widget at a minimum has a timeline provider and an entry view. The timeline provider says how often the widget should trigger an update check, and the entry view is the actual presentation. In the example there's also a preview provider, which is what's seen in the preview of the widget (AKA when you are adding the widget to your phone).
5. Looking at entry view first, it must have a keyword "entry" which is the data model of the widget, and a "body" keyword which is the swift UI view that renders the widget. 
6. The examples timeline provider shows a simple timeline of when the widget should update. This is a "best attempt" and not 100% reliable, as phones may choose to skip updates if it's happened too often (as mentioned in 1. strategy), or if the phones too busy, or some other black box magical reason. In my experience, it's generally fine, but docs say to consider it a best fit.
7. The timeline provider in the example has "func placeholder" which simply returns a empty entry. This defines a placeholder view for the widget, typically to be shown when the widget has no data available or is loading. It’s mainly a design template with static, placeholder content that gives users an idea of the widget layout. It's used when the widget is first loading data, the widget doesn’t have up-to-date data available, and often the very first thing shown until the widget’s timeline entries are fetched and displayed.
8. In the example, getTimeline is requesting an update every 15 minutes. You can do more complicated setups like varying time differences if you need, as per apple docs.
9. The getSnapshot provides a quick, static snapshot of the widget's view. It’s used in situations where a quick, approximate display of the widget is needed, like when users are browsing available widgets in the widget gallery, the system quickly needs a single snapshot of the widget’s content (e.g., when first adding it to the Home Screen), or if the widget doesn’t need to show real-time data or only has static content, getSnapshot can be used to bypass the timeline.
10. Assets.xcassets is auto generated when you create a xcode widgets project and updated when you adjust required assets.
11. MyData.swift shows how to keep models separate if you prefer that. Do not use subfolders.
12. Module.swift shows the expo module code which is quite self explanatory.
13. LogHandler is an example of logging if required.
14. Font+families.swift shows a simple way to use swift extensions.

Now you shoud have a baseline to start exploring from. I advise you create a separate xcode project and then create the widgets there. Then copy over the widget files when ready to build it. If you add dependencies, make sure to keep checking your app works. If you have complex timeline provider requirements I strongly recommend adjusting the timeline, and then adjusting the widget UI to show the last updated date. Then verify it in a dev build and see how it's working before doing widget UI work.

NB:: the code below fixes a margin introduced in widgets for iOS 17, that broke widgets all over the place. If you design widgets and want no margin, use the below code (pop it anywhere). 

```
extension WidgetConfiguration
{
    func contentMarginsDisabledIfAvailable() -> some WidgetConfiguration
    {
        #if compiler(>=5.9) // XCode 15
          if #available(iOSApplicationExtension 17.0, *)
          {
            return self.contentMarginsDisabled()
          }
          else
          {
              return self
          }
        #else
          return self
        #endif
    }
}
```

Here's an example using it:

```swift
struct UKBreakdownSmall_Widget: Widget {
    let kind: String = "UKBreakdownSmall_Widget"

    var body: some WidgetConfiguration {
        StaticConfiguration(kind: kind, provider: UKBreakdownSmall_Provider()) { entry in
            UKBreakdownSmall_EntryView(entry: entry)
            .background(.white)
            .foregroundColor(
              Color(
                #colorLiteral(
                    red: 54.0 / 255.0,
                    green: 54.0 / 255.0,
                    blue: 54.0 / 255.0,
                    alpha: 1
                )
            )
          )
        }
        .configurationDisplayName("UK Breakdown")
        .description("A breakdown of the UK renewable energy split in our national grid.")
        .supportedFamilies([.systemSmall])
        .contentMarginsDisabledIfAvailable()
    }
}
```

# android Guide

Android is a lot simpler. 

`./android/src/main/java/package_name/SampleWidget.kt` defines the widget provider aka the update logic. 
`./android/src/res/layout/sample_widget.xml` defines the widget UI
`./android/src/res/values/**.xml` defines various constants and strings used by the app (in xml files).
`./android/src/res/xml/sample_widget_info.xml` defines how often the widget should try to auto-update.



