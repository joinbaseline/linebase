```kotlin
package com.example.widget

import android.Manifest
import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.util.TypedValue
import android.view.View
import android.widget.RemoteViews
import androidx.core.content.ContextCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONException
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale
import java.util.logging.Logger
import kotlin.math.roundToInt

val Log: Logger = Logger.getLogger(MyWidgetProvider::class.java.name)

class MyWidgetProvider : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        super.onUpdate(context, appWidgetManager, appWidgetIds)

        val intent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_IMMUTABLE)
        val views = RemoteViews(context.packageName, R.layout.breakdown_widget)
        views.setOnClickPendingIntent(R.id.main_layout, pendingIntent)

        // There may be multiple widgets active, so update all of them
        for (appWidgetId in appWidgetIds) {
            CoroutineScope(Dispatchers.Main).launch {
                updateAppWidget(context, appWidgetManager, appWidgetId, views)
            }
        }
    }

    override fun onReceive(context: Context, intent: Intent?) {
        super.onReceive(context, intent)

        if (intent?.action == "android.intent.action.BOOT_COMPLETED") {
            val appWidgetManager = AppWidgetManager.getInstance(context)
            val appWidgetIds = appWidgetManager.getAppWidgetIds(
                ComponentName(context, MyWidgetProvider::class.java)
            )

            val updateIntent = Intent(context, MainActivity::class.java)
            val pendingIntent = PendingIntent.getActivity(context, 0, updateIntent, PendingIntent.FLAG_IMMUTABLE)
            val views = RemoteViews(context.packageName, R.layout.breakdown_widget)
            views.setOnClickPendingIntent(R.id.main_layout, pendingIntent)

            // There may be multiple widgets active, so update all of them
            for (appWidgetId in appWidgetIds) {
                CoroutineScope(Dispatchers.Main).launch {
                    updateAppWidget(context, appWidgetManager, appWidgetId, views)
                }
            }
        }
    }

    override fun onEnabled(context: Context) {
        super.onEnabled(context)
        // Enter relevant functionality for when the first widget is created
    }

    override fun onDisabled(context: Context) {
        super.onDisabled(context)
        // Enter relevant functionality for when the last widget is disabled
    }

    override fun onAppWidgetOptionsChanged(
        context: Context?,
        appWidgetManager: AppWidgetManager?,
        appWidgetId: Int,
        newOptions: Bundle?
    ) {
        super.onAppWidgetOptionsChanged(context, appWidgetManager, appWidgetId, newOptions)

        fun pxToSp(context: Context?, px: Float): Float {
            if (context == null) {
                return 9f;
            }

            return TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_PX, px, context.resources.displayMetrics
            )
        }
    }
}

data class NGData (
    var totalPct: Int = 0,
    var fossilPct: Int = 0,
    var gasPct: Int = 0,
    var coalPct: Int = 0,
    var biomassPct: Int = 0,
    var nuclearPct: Int = 0,
    var hydroPct: Int = 0,
    var importsPct: Int = 0,
    var otherPct: Int = 0,
    var windPct: Int = 0,
    var solarPct: Int = 0,
    var fromISO: String = "",
    var toISO: String = ""
)

data class AveragesData(
    var yd: Double = 0.0,
    var mo: Double = 0.0,
    var yr: Double = 0.0,
    var ts: String = ""
)

data class WidgetData(
    var dateStr: String = "01",
    var cleanPct: Int = 0,
    var month: String = "APR",
    var longMonth: String = "April",
    var year: Int = 2024,
    var fossilPct: Int = 0,
    var solarPct: Int = 0,
    var windPct: Int = 0,
    var nuclearPct: Int = 0,
    var bioPct: Int = 0,
    var hydroPct: Int = 0,
    var yesterdayAvg: Int = 0,
    var monthAvg: Int = 0,
    var yearAvg: Int = 0
)

fun getCachedAveragesData(context: Context): AveragesData? {
    var json =
        context.getSharedPreferences("${context.packageName}.avgsdata", Context.MODE_PRIVATE)
            .getString("averages", "{}")

    if (json == null) {
        Log.warning("No averages found in shared preferences!")
        return null
    }

    try {
        val data = JSONObject(json)
        return AveragesData(
            yd = data.getDouble("yd"),
            mo = data.getDouble("mo"),
            yr = data.getDouble("yr"),
            ts = data.getString("ts")
        )
    } catch (e: JSONException) {
        Log.warning("An error occurred parsing cached averages json!")
        Log.warning(e.message)
        return null
    }
}

fun cacheNGData(context: Context, ngData: NGData) {
    try {
        val jsonObject = JSONObject()
        jsonObject.put("totalPct", ngData.totalPct)
        jsonObject.put("fossilPct", ngData.fossilPct)
        jsonObject.put("gasPct", ngData.gasPct)
        jsonObject.put("coalPct", ngData.coalPct)
        jsonObject.put("biomassPct", ngData.biomassPct)
        jsonObject.put("nuclearPct", ngData.nuclearPct)
        jsonObject.put("hydroPct", ngData.hydroPct)
        jsonObject.put("importsPct", ngData.importsPct)
        jsonObject.put("otherPct", ngData.otherPct)
        jsonObject.put("windPct", ngData.windPct)
        jsonObject.put("solarPct", ngData.solarPct)
        jsonObject.put("fromISO", ngData.fromISO)
        jsonObject.put("toISO", ngData.toISO)

        val jsonString = jsonObject.toString()

        Log.info("Caching NG Data:")
        Log.info(jsonString)

        context.getSharedPreferences("${context.packageName}.avgsdata", Context.MODE_PRIVATE)
            .edit()
            .putString("averages", jsonString)
    } catch (e: JSONException) {
        Log.warning("An error occurred parsing breakdown widget json!")
        Log.warning(e.message)
    }
}

fun cacheAverages(context: Context, averagesData: AveragesData) {
    try {
        val json = JSONObject()
        json.put("yd", averagesData.yd)
        json.put("mo", averagesData.mo)
        json.put("yr", averagesData.yr)
        json.put("ts", averagesData.ts)

        val jsonString = json.toString()
        Log.info("Caching averages:")
        Log.info(jsonString)

        context.getSharedPreferences("${context.packageName}.widgetdata", Context.MODE_PRIVATE)
            .edit()
            .putString("widgetdata", jsonString)
    } catch (e: JSONException) {
        Log.warning("An error occurred parsing breakdown widget json!")
        Log.warning(e.message)
    }
}

fun getCachedNGData(context: Context): NGData? {
    var json =
        context.getSharedPreferences("${context.packageName}.widgetdata", Context.MODE_PRIVATE)
            .getString("widgetdata", "{}")

    if (json == null) {
        Log.warning("No data found in shared preferences!")
        return null
    }

    return try {
        val data = JSONObject(json)
        NGData(
            totalPct = data.getInt("totalPct"),
            fossilPct = data.getInt("fossilPct"),
            gasPct = data.getInt("gasPct"),
            coalPct = data.getInt("coalPct"),
            biomassPct = data.getInt("biomassPct"),
            nuclearPct = data.getInt("nuclearPct"),
            hydroPct = data.getInt("hydroPct"),
            importsPct = data.getInt("importsPct"),
            otherPct = data.getInt("otherPct"),
            windPct = data.getInt("windPct"),
            solarPct = data.getInt("solarPct"),
            fromISO = data.getString("fromISO"),
            toISO = data.getString("toISO")
        )
    } catch (e: JSONException) {
        Log.warning("An error occurred parsing breakdown widget json!")
        Log.warning(e.message)
        return null
    }
}

fun updateViews(
    data: WidgetData,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int,
    views: RemoteViews
) {
    views.setTextViewText(R.id.heading, "UK ${data.cleanPct}% Clean Energy")
    views.setTextViewText(R.id.date, "${data.dateStr} ${data.month}\n${data.year}")
    views.setTextViewText(R.id.fossil_pct_text, "${data.fossilPct}%")
    views.setTextViewText(R.id.solar_pct_text, "${data.solarPct}%")
    views.setTextViewText(R.id.wind_pct_text, "${data.windPct}%")
    views.setTextViewText(R.id.nuclear_pct_text, "${data.nuclearPct}%")
    views.setTextViewText(R.id.bio_pct_text, "${data.bioPct}%")
    views.setTextViewText(R.id.hydro_pct_text, "${data.hydroPct}%")
    views.setTextViewText(R.id.yesterday_avg, "Yesterday ${data.yesterdayAvg}%")
    views.setTextViewText(R.id.month_avg, "${data.longMonth} ${data.monthAvg}%")
    views.setTextViewText(R.id.year_avg, "${data.year} ${data.yearAvg}%")
    views.setProgressBar(R.id.clean_progress, 100, data.cleanPct, false);

    // only viable thing that seems to work for widgets. Cant update style or anything else
    // just breaks at runtime.
    if (data.cleanPct >= 50) {
        views.setViewVisibility(R.id.clean_progress, View.VISIBLE)
        views.setViewVisibility(R.id.clean_progress_orange, View.GONE)
    } else {
        views.setViewVisibility(R.id.clean_progress, View.GONE)
        views.setViewVisibility(R.id.clean_progress_orange, View.VISIBLE)
    }

    // Instruct the widget manager to update the widget
    appWidgetManager.updateAppWidget(appWidgetId, views)
}

fun shouldUpdateNGData(cached: NGData?): Boolean {
    if (cached == null || cached.toISO.isNullOrEmpty()) {
        Log.info("Cached iso from string is null or empty. Require new NG update.")
        return true;
    }

    val formatter = SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'")
    val dateTime = formatter.parse(cached.toISO) ?: return true

    val now = Date()
    val minutesDifference = (now.time - dateTime.time!!) / (1000 * 60)
    Log.info("Minutes difference: $minutesDifference")

    val calendar = Calendar.getInstance()
    calendar.time = now
    val currentMinute = calendar.get(Calendar.MINUTE)
    calendar.time = dateTime!!
    val dateTimeMinute = calendar.get(Calendar.MINUTE)
    Log.info("currentMinute: $currentMinute")
    Log.info("dateTimeMinute: $dateTimeMinute")

    if (minutesDifference > 30) {
        Log.info("Minutes difference over 30. Require update.")
        return true
    } else if (dateTimeMinute < 30 && currentMinute >= 30) {
        Log.info("Last cached date was around the hour and now is past the half. Require update.")
        return true
    } else if (dateTimeMinute >= 30 && currentMinute < 30) {
        Log.info("Last cached data was around half past and now is just past the hour. Require update.")
        return true
    }
    Log.info("No update required.")
    return false
}

fun isYesterdayOrEarlier(date: Date): Boolean {
    // Get today's date at midnight
    val today = Calendar.getInstance()
    today.set(Calendar.HOUR_OF_DAY, 0)
    today.set(Calendar.MINUTE, 0)
    today.set(Calendar.SECOND, 0)
    today.set(Calendar.MILLISECOND, 0)

    val givenDate = Calendar.getInstance()
    givenDate.time = date

    // Compare with today's and yesterday's dates
    return givenDate.before(today)
}

fun shouldUpdateAverages(cached: AveragesData?): Boolean {
    if (cached == null || cached.ts.isNullOrEmpty()) {
        Log.info("Cached iso from string is null or empty. Require new NG update.")
        return true
    }

    val formatter = SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'")
    val dateTime = formatter.parse(cached.ts)

    if (isYesterdayOrEarlier(dateTime!!)) {
        Log.info("Averages update required; ts is yesterday or earlier.")
        return true
    }

    Log.info("No update required.")
    return false
}

suspend fun fetch(context: Context, urlStr: String): String? {
    return withContext(Dispatchers.IO) {
        try {
            if (ContextCompat.checkSelfPermission(
                    context,
                    Manifest.permission.INTERNET
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                // Permission denied, handle it accordingly
                return@withContext null
            }

            val url = URL(urlStr)

            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.connectTimeout = 10000 // Set your desired timeout
            connection.readTimeout = 10000 // Set your desired timeout

            val responseCode = connection.responseCode
            if (responseCode == HttpURLConnection.HTTP_OK) {
                val inputStream = connection.inputStream
                val reader = BufferedReader(InputStreamReader(inputStream))
                val response = StringBuilder()
                var line: String?
                while (reader.readLine().also { line = it } != null) {
                    response.append(line)
                }
                reader.close()
                connection.disconnect()
                response.toString()
            } else {
                null // Handle other HTTP response codes if needed
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}

suspend fun getGenerationMix(context: Context): NGData? {
    Log.info("Requesting generation mix.")
    val txt = fetch(context, "https://serverurl.com/api/getdata") ?: return null

    Log.info("Text read.")
    val json = JSONObject(txt).getJSONObject("data")
    Log.info("Generation mix received & parsed.")

    return NGData().apply {
        fromISO = json.getString("from")
        toISO = json.getString("to")

        val generationMixArray = json.getJSONArray("generationmix")

        for (i in 0 until generationMixArray.length()) {
            val mix = generationMixArray.getJSONObject(i)
            val perc = mix.getInt("perc")

            when (mix.getString("fuel")) {
                "biomass" -> {
                    biomassPct = perc
                    totalPct += perc
                }
                "hydro" ->{
                    hydroPct = perc
                    totalPct += perc
                }
                "nuclear" -> {
                    nuclearPct = perc
                    totalPct += perc
                }
                "wind" -> {
                    windPct = perc
                    totalPct += perc
                }
                "solar" -> {
                    solarPct = perc
                    totalPct += perc
                }
                "imports" -> {
                    importsPct = perc
                    fossilPct += perc
                }
                "coal" -> {
                    coalPct = perc
                    fossilPct += perc
                }
                "gas" -> {
                    gasPct = perc
                    fossilPct += perc
                }
                "other" -> {
                    otherPct += perc
                    fossilPct += perc
                }
            }
        }
    }
}

suspend fun getAverages(context: Context): AveragesData? {
    Log.info("Requesting get averages.")
    val txt = fetch(context, "https://serverurl.com/api/getdata") ?: return null
    val json = JSONObject(txt)
    Log.info("Requesting averages.")
    return AveragesData(
        yd = json.getDouble("yd"),
        mo = json.getDouble("mo"),
        yr = json.getDouble("yr"),
        ts = json.getString("ts")
    )
}

suspend fun getFreshData(context: Context, shouldGetGenerationMix: Boolean, shouldGetAverages: Boolean): Pair<NGData?, AveragesData?> {
    var response1: NGData? = null
    var response2: AveragesData? = null

    coroutineScope {
        val deferredResponse1 = if (shouldGetGenerationMix) async { getGenerationMix(context) } else null
        val deferredResponse2 = if (shouldGetAverages) async { getAverages(context) } else null

        response1 = deferredResponse1?.await()
        response2 = deferredResponse2?.await()
    }

    return Pair(response1, response2)
}

fun createNewWidgetData(generation: NGData, averages: AveragesData): WidgetData {
    val sdfInput = SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'", Locale.getDefault())
    val date: Date = sdfInput.parse(generation.toISO) ?: Date()

    val calendar = Calendar.getInstance()
    calendar.time = date

    val dateFormat = SimpleDateFormat("dd", Locale.getDefault())
    val dateStr = dateFormat.format(date)

    val monthFormat = SimpleDateFormat("MMM", Locale.getDefault())
    val monthStr = monthFormat.format(date)

    val longMonthFormat = SimpleDateFormat("MMMM", Locale.getDefault())
    val longMonth = longMonthFormat.format(date)

    return WidgetData(
        dateStr = dateStr,
        cleanPct = generation.totalPct,
        month = monthStr,
        longMonth = longMonth,
        year = calendar.get(Calendar.YEAR),
        fossilPct = generation.fossilPct,
        solarPct = generation.solarPct,
        windPct = generation.windPct,
        nuclearPct = generation.nuclearPct,
        bioPct = generation.biomassPct,
        hydroPct = generation.hydroPct,
        yesterdayAvg = averages.yd.roundToInt(),
        monthAvg = averages.mo.roundToInt(),
        yearAvg = averages.yr.roundToInt()
    )
}

internal suspend fun updateAppWidget(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int,
    views: RemoteViews
) {
    try {
        Log.info("SGetting cached NG Data")
        val cachedNGData = getCachedNGData(context)
        Log.info("SGetting cached Averages")
        val cachedAverages = getCachedAveragesData(context)

        Log.info("Checking if need NG update...")
        val updateNGData = shouldUpdateNGData(cachedNGData)
        Log.info("Should update NG: $updateNGData")
        Log.info("Checking if need averages update...")
        val updateAverages = shouldUpdateAverages(cachedAverages)
        Log.info("Should update averages: $updateAverages")

        val (ngData, averages) = getFreshData(context, updateNGData, updateAverages)
        Log.info("Obtained fresh data")

        val nonNullNGData = ngData ?: cachedNGData ?: NGData()
        val nonNullAverages = averages ?: cachedAverages ?: AveragesData()

        cacheNGData(context, nonNullNGData)
        cacheAverages(context, nonNullAverages)

        val widgetData = createNewWidgetData(
            nonNullNGData,
            nonNullAverages
        )

        Log.info(widgetData.dateStr)
        Log.info("Widget data object created, updating views")
        updateViews(widgetData, appWidgetManager, appWidgetId, views)
    }
    catch (e: Exception) {
        Log.warning("An error occurred setting breakdown widget info!")
        Log.warning("${e.message}")
    }
}
```